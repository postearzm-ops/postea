// Prisma Schema para LinkedIn/Twitter Automation con Telegram Approval

generator client {
  provider = "prisma-client-js"
  binaryTargets   = ["native", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
//  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  passwordHash String @map("password_hash")
  firstName String?  @map("first_name")
  lastName  String?  @map("last_name")
  
  // LinkedIn OAuth tokens
  linkedinAccessToken  String?   @map("linkedin_access_token") @db.Text
  linkedinRefreshToken String?   @map("linkedin_refresh_token") @db.Text
  linkedinTokenExpiry  DateTime? @map("linkedin_token_expiry")
  linkedinUserId       String?   @map("linkedin_user_id")
  
  // Twitter/X OAuth tokens
  twitterAccessToken  String?   @map("twitter_access_token") @db.Text
  twitterRefreshToken String?   @map("twitter_refresh_token") @db.Text
  twitterTokenExpiry  DateTime? @map("twitter_token_expiry")
  twitterUserId       String?   @map("twitter_user_id")
  twitterUsername     String?   @map("twitter_username")
  
  // Telegram configuration
  telegramChatId      String?   @map("telegram_chat_id")
  telegramUsername    String?   @map("telegram_username")
  telegramEnabled     Boolean   @default(false) @map("telegram_enabled")
  
  // User preferences
  timezone             String    @default("UTC")
  language             String    @default("es")
  notificationsEnabled Boolean   @default(true) @map("notifications_enabled")
  autoPublishEnabled   Boolean   @default(false) @map("auto_publish_enabled") // Si false, requiere aprobación
  
  // Metadata
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  lastLoginAt DateTime? @map("last_login_at")
  
  // Relations
  topics        Topic[]
  posts         Post[]
  refreshTokens RefreshToken[]
  
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique @db.Text
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("refresh_tokens")
}

model Topic {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  name        String
  description String?
  keywords    String[] // Array de palabras clave
  language    String   @default("es")
  isActive    Boolean  @default(true) @map("is_active")
  
  // Configuración de publicación
  postFrequency Int @default(1) @map("post_frequency") // Posts por día
  preferredTimes String[] @default(["09:00", "14:00"]) @map("preferred_times")
  
  // Plataformas de destino
  platforms Platform[] @default([LINKEDIN]) // LinkedIn, Twitter, o ambos
  
  // Metadata
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  newsItems NewsItem[]
  
  @@index([userId, isActive])
  @@map("topics")
}

model NewsItem {
  id          String   @id @default(uuid())
  topicId     String   @map("topic_id")
  
  // Contenido de la noticia
  title       String
  description String?  @db.Text
  content     String?  @db.Text
  url         String
  urlToImage  String?  @map("url_to_image")
  
  // Metadata de la fuente
  source      String
  author      String?
  publishedAt DateTime @map("published_at")
  
  // Análisis
  relevanceScore Float?   @default(0) @map("relevance_score")
  sentiment      String?  // positive, neutral, negative
  category       String?
  
  // Sistema
  fetchedAt DateTime @default(now()) @map("fetched_at")
  isProcessed Boolean @default(false) @map("is_processed")
  
  // Relations
  topic Topic  @relation(fields: [topicId], references: [id], onDelete: Cascade)
  posts Post[]
  
  @@index([topicId, publishedAt])
  @@index([relevanceScore])
  @@map("news_items")
}

model Post {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  newsItemId  String?  @map("news_item_id")
  
  // Contenido del post
  content     String   @db.Text
  hashtags    String[]
  
  // Plataforma de destino
  platform    Platform @default(LINKEDIN)
  
  // Estado y programación
  status      PostStatus @default(DRAFT)
  scheduledFor DateTime? @map("scheduled_for")
  publishedAt DateTime?  @map("published_at")
  
  // Aprobación por Telegram
  approvalStatus    ApprovalStatus @default(PENDING) @map("approval_status")
  telegramMessageId Int?           @map("telegram_message_id")
  approvedAt        DateTime?      @map("approved_at")
  approvedBy        String?        @map("approved_by") // Telegram username
  rejectedAt        DateTime?      @map("rejected_at")
  rejectionReason   String?        @map("rejection_reason") @db.Text
  
  // LinkedIn data
  linkedinPostId  String? @map("linkedin_post_id")
  linkedinUrn     String? @map("linkedin_urn")
  
  // Twitter/X data
  twitterPostId   String? @map("twitter_post_id")
  twitterUrl      String? @map("twitter_url")
  
  // Métricas
  impressions Int?     @default(0)
  reactions   Int?     @default(0)
  comments    Int?     @default(0)
  shares      Int?     @default(0)
  retweets    Int?     @default(0) // Para Twitter
  
  // Error handling
  errorMessage String? @map("error_message") @db.Text
  retryCount   Int     @default(0) @map("retry_count")
  
  // Metadata
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  newsItem NewsItem? @relation(fields: [newsItemId], references: [id], onDelete: SetNull)
  
  @@index([userId, status])
  @@index([scheduledFor])
  @@index([approvalStatus])
  @@index([platform, status])
  @@map("posts")
}

enum Platform {
  LINKEDIN
  TWITTER
}

enum PostStatus {
  DRAFT
  PENDING_APPROVAL  // Enviado a Telegram, esperando respuesta
  APPROVED          // Aprobado por Telegram
  REJECTED          // Rechazado por Telegram
  SCHEDULED
  PUBLISHING
  PUBLISHED
  FAILED
  CANCELLED
}

enum ApprovalStatus {
  PENDING           // Esperando aprobación
  APPROVED          // Aprobado manualmente
  REJECTED          // Rechazado manualmente
  AUTO_APPROVED     // Aprobado automáticamente (si está habilitado)
  EXPIRED           // La aprobación expiró (timeout)
}

model TelegramMessage {
  id              String   @id @default(uuid())
  chatId          String   @map("chat_id")
  messageId       Int      @map("message_id")
  postId          String?  @map("post_id")
  messageType     String   @map("message_type") // approval_request, notification, etc.
  
  // Contenido del mensaje
  text            String?  @db.Text
  
  // Respuesta
  responseReceived Boolean  @default(false) @map("response_received")
  responseText     String?  @map("response_text")
  responseAt       DateTime? @map("response_at")
  
  // Metadata
  sentAt      DateTime @default(now()) @map("sent_at")
  expiresAt   DateTime? @map("expires_at")
  
  @@index([chatId, messageId])
  @@index([postId])
  @@map("telegram_messages")
}

model SystemLog {
  id        String   @id @default(uuid())
  level     LogLevel
  message   String   @db.Text
  metadata  Json?
  source    String?
  userId    String?  @map("user_id")
  
  createdAt DateTime @default(now()) @map("created_at")
  
  @@index([level, createdAt])
  @@index([userId])
  @@map("system_logs")
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
  FATAL
}

model JobQueue {
  id          String     @id @default(uuid())
  jobType     String     @map("job_type")
  payload     Json
  status      JobStatus  @default(PENDING)
  priority    Int        @default(0)
  
  attempts    Int        @default(0)
  maxAttempts Int        @default(3) @map("max_attempts")
  
  scheduledFor DateTime? @map("scheduled_for")
  startedAt   DateTime?  @map("started_at")
  completedAt DateTime?  @map("completed_at")
  failedAt    DateTime?  @map("failed_at")
  
  errorMessage String?   @map("error_message") @db.Text
  result      Json?
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@index([status, priority, scheduledFor])
  @@index([jobType, status])
  @@map("job_queue")
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

model Analytics {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  platform  Platform? // LinkedIn, Twitter, o null para agregado
  
  // Métricas del día
  date      DateTime @db.Date
  
  postsPublished Int @default(0) @map("posts_published")
  totalImpressions Int @default(0) @map("total_impressions")
  totalReactions Int @default(0) @map("total_reactions")
  totalComments Int @default(0) @map("total_comments")
  totalShares Int @default(0) @map("total_shares")
  
  // Métricas específicas de Twitter
  totalRetweets Int @default(0) @map("total_retweets")
  
  // Aprobación
  postsApproved Int @default(0) @map("posts_approved")
  postsRejected Int @default(0) @map("posts_rejected")
  avgApprovalTime Float? @map("avg_approval_time") // En minutos
  
  // Engagement rate
  engagementRate Float? @map("engagement_rate")
  
  // Metadata
  createdAt DateTime @default(now()) @map("created_at")
  
  @@unique([userId, date, platform])
  @@index([userId, date])
  @@map("analytics")
}
